{"ast":null,"code":"import { getChars, getWords, setShadow } from '../../core/utils';\nexport var DEFAULT_MEASURE = [[], 0];\n\nfunction measureLines(canvas, chars, boxWidth, numberOfLines) {\n  var lines = [];\n  var width = 0;\n  var text = '';\n  var cursor = -1;\n\n  function pushLine() {\n    var charWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var char = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (force || text) {\n      lines.push({\n        width: width,\n        text: text\n      });\n    }\n\n    if (cursor < chars.length && numberOfLines > 0 && lines.length >= numberOfLines) {\n      var lastLine = lines[lines.length - 1];\n      lastLine.text = \"\".concat(lastLine.text.slice(0, -2), \"...\");\n      lastLine.width = canvas.context.measureText(lastLine.text).width;\n      cursor = chars.length + 1;\n    } else {\n      width = charWidth;\n      text = char.trim();\n    }\n  }\n\n  while (cursor++ <= chars.length) {\n    if (chars.length > cursor) {\n      var char = chars[cursor];\n\n      if (char === '\\n') {\n        pushLine(0, '', true);\n      } else {\n        var charWidth = canvas.context.measureText(char).width;\n\n        if (charWidth + width > boxWidth) {\n          pushLine(charWidth, char);\n        } else {\n          width += charWidth;\n          text += char;\n        }\n      }\n    } else {\n      pushLine();\n    }\n  }\n\n  return lines;\n}\n\nfunction splitContent(content, wordBreak) {\n  switch (wordBreak) {\n    case 'break-all':\n      return getChars(content);\n\n    case 'keep-all':\n      return [content];\n\n    default:\n      return getWords(content);\n  }\n}\n\nexport function applyTextStyle(canvas, options) {\n  var _options$textStyle = options.textStyle,\n      fontStyle = _options$textStyle.fontStyle,\n      fontWeight = _options$textStyle.fontWeight,\n      fontSize = _options$textStyle.fontSize,\n      fontFamily = _options$textStyle.fontFamily,\n      textBaseline = _options$textStyle.textBaseline,\n      color = _options$textStyle.color; // Apply Styles\n\n  canvas.context.font = \"\".concat(fontStyle, \" \").concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n  canvas.context.fillStyle = color;\n  canvas.context.textBaseline = textBaseline;\n}\nexport function measureText(canvas, options) {\n  var lines = measureLines(canvas, splitContent(options.content, options.textStyle.wordBreak), options.frame.width, options.numberOfLines);\n  return [lines, options.textStyle.lineHeight * lines.length];\n}\nexport function drawText(canvas, options, lines) {\n  var style = options.textStyle,\n      frame = options.frame; // Shadow:\n\n  var resetShadow = setShadow(canvas, style.textShadowColor, style.textShadowOffsetX, style.textShadowOffsetY, style.textShadowBlur);\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var x = frame.x;\n\n    switch (style.textAlign) {\n      case 'center':\n        x = x + frame.width / 2 - line.width / 2;\n        break;\n\n      case 'right':\n        x = x + frame.width - line.width;\n        break;\n    }\n\n    canvas.context.fillText(line.text, x, style.lineHeight * (i + 0.5) + frame.y);\n  }\n\n  resetShadow();\n}","map":{"version":3,"sources":["/Users/fimplus/Desktop/revasReal/src/revas/components/common/drawText.ts"],"names":["getChars","getWords","setShadow","DEFAULT_MEASURE","measureLines","canvas","chars","boxWidth","numberOfLines","lines","width","text","cursor","pushLine","charWidth","char","force","push","length","lastLine","slice","context","measureText","trim","splitContent","content","wordBreak","applyTextStyle","options","textStyle","fontStyle","fontWeight","fontSize","fontFamily","textBaseline","color","font","fillStyle","frame","lineHeight","drawText","style","resetShadow","textShadowColor","textShadowOffsetX","textShadowOffsetY","textShadowBlur","i","line","x","textAlign","fillText","y"],"mappings":"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","sourcesContent":["import { Frame } from '../../core/Node';\nimport { getChars, getWords, setShadow } from '../../core/utils';\nimport { RevasCanvas } from '../../core/Canvas';\n\nexport interface DrawTextOptions {\n  textStyle: any;\n  numberOfLines: number;\n  frame: Frame;\n  content: string;\n}\n\nexport type MeasureLine = { width: number; text: string };\n\nexport type MeasureResult = [MeasureLine[], number];\n\nexport const DEFAULT_MEASURE: MeasureResult = [[], 0];\n\nfunction measureLines(canvas: RevasCanvas, chars: readonly string[], boxWidth: number, numberOfLines: number) {\n  const lines: MeasureLine[] = [];\n  let width = 0;\n  let text = '';\n  let cursor = -1;\n  function pushLine(charWidth = 0, char = '', force = false) {\n    if (force || text) {\n      lines.push({ width, text });\n    }\n    if (cursor < chars.length && numberOfLines > 0 && lines.length >= numberOfLines) {\n      const lastLine = lines[lines.length - 1];\n      lastLine.text = `${lastLine.text.slice(0, -2)}...`;\n      lastLine.width = canvas.context.measureText(lastLine.text).width;\n      cursor = chars.length + 1;\n    } else {\n      width = charWidth;\n      text = char.trim();\n    }\n  }\n  while (cursor++ <= chars.length) {\n    if (chars.length > cursor) {\n      const char = chars[cursor];\n      if (char === '\\n') {\n        pushLine(0, '', true);\n      } else {\n        const charWidth = canvas.context.measureText(char).width;\n        if (charWidth + width > boxWidth) {\n          pushLine(charWidth, char);\n        } else {\n          width += charWidth;\n          text += char;\n        }\n      }\n    } else {\n      pushLine();\n    }\n  }\n  return lines;\n}\n\nfunction splitContent(content: string, wordBreak: string) {\n  switch (wordBreak) {\n    case 'break-all':\n      return getChars(content);\n    case 'keep-all':\n      return [content];\n    default:\n      return getWords(content);\n  }\n}\n\nexport function applyTextStyle(canvas: RevasCanvas, options: DrawTextOptions) {\n  const { fontStyle, fontWeight, fontSize, fontFamily, textBaseline, color } = options.textStyle;\n  // Apply Styles\n  canvas.context.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n  canvas.context.fillStyle = color;\n  canvas.context.textBaseline = textBaseline;\n}\n\nexport function measureText(canvas: RevasCanvas, options: DrawTextOptions): MeasureResult {\n  const lines = measureLines(\n    canvas,\n    splitContent(options.content, options.textStyle.wordBreak),\n    options.frame.width,\n    options.numberOfLines\n  );\n  return [lines, options.textStyle.lineHeight * lines.length];\n}\n\nexport function drawText(canvas: RevasCanvas, options: DrawTextOptions, lines: MeasureLine[]) {\n  const { textStyle: style, frame } = options;\n\n  // Shadow:\n  const resetShadow = setShadow(\n    canvas,\n    style.textShadowColor,\n    style.textShadowOffsetX,\n    style.textShadowOffsetY,\n    style.textShadowBlur\n  );\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    let { x } = frame;\n    switch (style.textAlign) {\n      case 'center':\n        x = x + frame.width / 2 - line.width / 2;\n        break;\n      case 'right':\n        x = x + frame.width - line.width;\n        break;\n    }\n    canvas.context.fillText(line.text, x, style.lineHeight * (i + 0.5) + frame.y);\n  }\n  resetShadow();\n}\n"]},"metadata":{},"sourceType":"module"}