{"ast":null,"code":"import { getFrameFromNode, getMergedStyleFromNode, sortByZIndexAscending } from \"./utils\";\n\nfunction scaled(x, c) {\n  var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (!s && s === 1) return x;\n  return ((s - 1) * c + x) / s;\n}\n\nfunction findNodeByPoint(node, x, y) {\n  if (node.props.pointerEvents === 'none') return;\n  var children = node.children.slice().sort(sortByZIndexAscending).reverse();\n  var style = getMergedStyleFromNode(node);\n  var frame = getFrameFromNode(node); // tranlate\n\n  var scaleX = style.scaleX || style.scale;\n  var scaleY = style.scaleY || style.scale;\n  var originX = frame.width / 2 + frame.x;\n  var originY = frame.height / 2 + frame.y;\n  x -= style.translateX || 0;\n  y -= style.translateY || 0;\n  x = scaled(x, originX, scaleX);\n  y = scaled(y, originY, scaleY);\n\n  if (frame.x < x && frame.y < y && x <= frame.x + frame.width && y <= frame.y + frame.height) {\n    for (var i = 0; i < children.length; i++) {\n      var target = findNodeByPoint(children[i], x, y);\n      if (target) return target;\n    }\n\n    if (node.props.pointerEvents === 'box-none') return;\n    return node;\n  }\n}\n\nvar eventNodeHolder = {};\nexport function getNodeByTouch(root, type, touch) {\n  if (type === 'touchstart') {\n    var target = findNodeByPoint(root, touch.x, touch.y);\n    eventNodeHolder[touch.identifier] = target || root;\n    return eventNodeHolder[touch.identifier];\n  } else if (type === 'touchmove') {\n    return eventNodeHolder[touch.identifier] || root;\n  } else if (type === 'touchend') {\n    var _target = eventNodeHolder[touch.identifier];\n    delete eventNodeHolder[touch.identifier];\n    return _target || root;\n  }\n\n  return root;\n}\nvar LISTENER_MAP = {\n  touchstart: 'onTouchStart',\n  touchmove: 'onTouchMove',\n  touchend: 'onTouchEnd'\n};\nexport function emitTouch(node, e) {\n  var funcName = LISTENER_MAP[e.type];\n\n  if (funcName) {\n    while (node) {\n      if (node.props[funcName] && node.props.pointerEvents !== 'box-none' && node.props[funcName](e) === false) return;\n      node = node.parent;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/fimplus/Desktop/revasReal/src/revas/core/touch.ts"],"names":["getFrameFromNode","getMergedStyleFromNode","sortByZIndexAscending","scaled","x","c","s","findNodeByPoint","node","y","props","pointerEvents","children","slice","sort","reverse","style","frame","scaleX","scale","scaleY","originX","width","originY","height","translateX","translateY","i","length","target","eventNodeHolder","getNodeByTouch","root","type","touch","identifier","LISTENER_MAP","touchstart","touchmove","touchend","emitTouch","e","funcName","parent"],"mappings":"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","sourcesContent":["import { getFrameFromNode, getMergedStyleFromNode, sortByZIndexAscending } from \"./utils\"\nimport { Node, RevasTouchEvent, RevasTouchType, RevasTouch } from \"./Node\"\n\nfunction scaled(x: number, c: number, s = 1) {\n  if (!s && s === 1) return x\n  return ((s - 1) * c + x) / s\n}\n\nfunction findNodeByPoint(node: Node, x: number, y: number): Node | void {\n  if (node.props.pointerEvents === 'none') return\n\n  const children = node.children.slice().sort(sortByZIndexAscending).reverse()\n  const style = getMergedStyleFromNode(node)\n  const frame = getFrameFromNode(node)\n\n  // tranlate\n  const scaleX = style.scaleX || style.scale\n  const scaleY = style.scaleY || style.scale\n  const originX = frame.width / 2 + frame.x\n  const originY = frame.height / 2 + frame.y\n\n  x -= style.translateX || 0\n  y -= style.translateY || 0\n  x = scaled(x, originX, scaleX)\n  y = scaled(y, originY, scaleY)\n\n  if (frame.x < x && frame.y < y\n    && x <= frame.x + frame.width\n    && y <= frame.y + frame.height) {\n\n    for (let i = 0; i < children.length; i++) {\n      const target = findNodeByPoint(children[i], x, y)\n      if (target) return target\n    }\n\n    if (node.props.pointerEvents === 'box-none') return\n\n    return node\n  }\n}\n\nconst eventNodeHolder: { [key: number]: Node } = {}\n\nexport function getNodeByTouch(root: Node, type: RevasTouchType, touch: RevasTouch) {\n  if (type === 'touchstart') {\n    const target = findNodeByPoint(root, touch.x, touch.y)\n    eventNodeHolder[touch.identifier] = target || root\n    return eventNodeHolder[touch.identifier]\n  } else if (type === 'touchmove') {\n    return eventNodeHolder[touch.identifier] || root\n  } else if (type === 'touchend') {\n    const target = eventNodeHolder[touch.identifier]\n    delete eventNodeHolder[touch.identifier]\n    return target || root\n  }\n  return root\n}\n\nconst LISTENER_MAP = {\n  touchstart: 'onTouchStart',\n  touchmove: 'onTouchMove',\n  touchend: 'onTouchEnd'\n}\n\n\nexport function emitTouch(node: Node | void, e: RevasTouchEvent) {\n  const funcName = LISTENER_MAP[e.type]\n  if (funcName) {\n    while (node) {\n      if (node.props[funcName]\n        && node.props.pointerEvents !== 'box-none'\n        && node.props[funcName](e) === false) return\n      node = node.parent\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}