{"ast":null,"code":"import { getMergedStyleFromNode, getFrameFromNode, sortByZIndexAscending, setShadow, pushOpacity, adapter } from './utils';\nimport { getCache, createCache, autoCacheId } from './offscreen';\n\nfunction getRadius(style) {\n  return {\n    tl: style.borderTopLeftRadius || style.borderRadius || 0,\n    tr: style.borderTopRightRadius || style.borderRadius || 0,\n    bl: style.borderBottomLeftRadius || style.borderRadius || 0,\n    br: style.borderBottomRightRadius || style.borderRadius || 0\n  };\n}\n\nexport function drawNode(canvas, node, container) {\n  var style = getMergedStyleFromNode(node, container.draw);\n  var frame = getFrameFromNode(node);\n\n  if (style.opacity <= 0) {\n    return;\n  } // flags\n\n\n  var hasTransform = style.translateX || style.translateY || style.rotate || style.scaleX || style.scaleY || style.scale;\n  var hasClip = style.overflow === 'hidden';\n\n  if (hasClip) {\n    canvas.context.save();\n  } else if (hasTransform) {\n    canvas.transform.save();\n  } // Area Range\n  // Opacity:\n\n\n  var popOpacity = pushOpacity(canvas, style.opacity); // Translation:\n\n  if (style.translateX || style.translateY) {\n    canvas.transform.translate(style.translateX || 0, style.translateY || 0);\n  } // Rotate && Scale\n\n\n  if (style.rotate || style.scaleX || style.scaleY || style.scale) {\n    // Origin Center\n    var originX = frame.x + frame.width / 2;\n    var originY = frame.y + frame.height / 2;\n    canvas.transform.translate(originX, originY);\n\n    if (style.rotate) {\n      canvas.transform.rotate(style.rotate);\n    }\n\n    if (style.scaleX || style.scaleY || style.scale) {\n      canvas.transform.scale(style.scaleX || style.scale, style.scaleY || style.scale);\n    }\n\n    canvas.transform.translate(-originX, -originY);\n  }\n\n  if (node.props.cache && adapter.createOffscreenCanvas && frame.height > 0 && frame.width > 0) {\n    drawCache(canvas, node, container, style, frame, hasClip);\n  } else {\n    drawContent(canvas, node, container, style, frame, hasClip);\n  }\n\n  popOpacity();\n\n  if (hasClip) {\n    canvas.context.restore();\n  } else if (hasTransform) {\n    canvas.transform.restore();\n  }\n}\n\nfunction drawCache(canvas, node, container, style, frame, hasClip) {\n  var cachedId = node.props.cache === true ? autoCacheId(node) : node.props.cache;\n  var cached = getCache(cachedId);\n\n  var _ref = cached ? cached.style : style,\n      _ref$shadowBlur = _ref.shadowBlur,\n      shadowBlur = _ref$shadowBlur === void 0 ? 0 : _ref$shadowBlur,\n      _ref$shadowOffsetX = _ref.shadowOffsetX,\n      shadowOffsetX = _ref$shadowOffsetX === void 0 ? 0 : _ref$shadowOffsetX,\n      _ref$shadowOffsetY = _ref.shadowOffsetY,\n      shadowOffsetY = _ref$shadowOffsetY === void 0 ? 0 : _ref$shadowOffsetY;\n\n  var spread = shadowBlur * 2;\n  var x = frame.x + shadowOffsetX - shadowBlur;\n  var y = frame.y + shadowOffsetY - shadowBlur;\n  var w = frame.width + spread;\n  var h = frame.height + spread;\n\n  if (!cached) {\n    if (!node.$ready && !node.props.forceCache) {\n      return drawContent(canvas, node, container, style, frame, hasClip);\n    }\n\n    cached = createCache(style, w, h, cachedId);\n    cached.canvas.transform.translate(-x, -y);\n    drawContent(cached.canvas, node, container, style, frame, hasClip);\n    cached.canvas.transform.translate(x, y);\n  }\n\n  canvas.context.drawImage(cached.canvas.element, x, y, w, h);\n}\n\nfunction drawContent(canvas, node, container, style, frame, hasClip) {\n  var hasBG = style.backgroundColor && style.backgroundColor !== 'transparent';\n  var hasBorder = style.borderColor && style.borderWidth > 0;\n  var hasRadius = style.borderRadius || style.borderTopLeftRadius || style.borderTopRightRadius || style.borderBottomLeftRadius || style.borderBottomRightRadius; // consts\n\n  var useFrame = hasBG || hasBorder || hasClip || style.path;\n  var usePath = hasRadius || hasClip || style.path;\n\n  if (useFrame) {\n    var ctx = canvas.context;\n\n    if (usePath) {\n      // Draw Path\n      ctx.beginPath();\n\n      if (hasRadius) {\n        var radius = getRadius(style);\n        ctx.moveTo(frame.x + radius.tl, frame.y);\n        ctx.arcTo(frame.x + frame.width, frame.y, frame.x + frame.width, frame.y + frame.height, radius.tr);\n        ctx.arcTo(frame.x + frame.width, frame.y + frame.height, frame.x, frame.y + frame.height, radius.br);\n        ctx.arcTo(frame.x, frame.y + frame.height, frame.x, frame.y, radius.bl);\n        ctx.arcTo(frame.x, frame.y, frame.x + frame.width, frame.y, radius.tl);\n      } else {\n        ctx.rect(frame.x, frame.y, frame.width, frame.height);\n      }\n\n      ctx.closePath();\n\n      if (hasClip) {\n        ctx.clip();\n      }\n    }\n\n    if (hasBG || hasBorder) {\n      // Shadow:\n      var resetShadow = setShadow(canvas, style.shadowColor, style.shadowOffsetX, style.shadowOffsetY, style.shadowBlur); // Background color & Shadow\n\n      if (hasBG) {\n        ctx.fillStyle = style.backgroundColor;\n\n        if (usePath) {\n          ctx.fill();\n        } else {\n          ctx.fillRect(frame.x, frame.y, frame.width, frame.height);\n        }\n      } // Border with border radius:\n\n\n      if (hasBorder) {\n        ctx.lineWidth = style.borderWidth;\n        ctx.strokeStyle = style.borderColor;\n\n        if (usePath) {\n          ctx.stroke();\n        } else {\n          ctx.strokeRect(frame.x, frame.y, frame.width, frame.height);\n        }\n      }\n\n      resetShadow();\n    }\n  }\n\n  if (node.props.customDrawer) {\n    node.props.customDrawer(canvas, node, {\n      hasRadius: hasRadius,\n      hasClip: hasClip\n    });\n  } // Draw child layers, sorted by their z-index.\n\n\n  node.children.slice().sort(sortByZIndexAscending).forEach(function drawChild(child) {\n    drawNode(canvas, child, container);\n  });\n}","map":{"version":3,"sources":["/Users/fimplus/Desktop/revasReal/src/revas/core/draw.ts"],"names":["getMergedStyleFromNode","getFrameFromNode","sortByZIndexAscending","setShadow","pushOpacity","adapter","getCache","createCache","autoCacheId","getRadius","style","tl","borderTopLeftRadius","borderRadius","tr","borderTopRightRadius","bl","borderBottomLeftRadius","br","borderBottomRightRadius","drawNode","canvas","node","container","draw","frame","opacity","hasTransform","translateX","translateY","rotate","scaleX","scaleY","scale","hasClip","overflow","context","save","transform","popOpacity","translate","originX","x","width","originY","y","height","props","cache","createOffscreenCanvas","drawCache","drawContent","restore","cachedId","cached","shadowBlur","shadowOffsetX","shadowOffsetY","spread","w","h","$ready","forceCache","drawImage","element","hasBG","backgroundColor","hasBorder","borderColor","borderWidth","hasRadius","useFrame","path","usePath","ctx","beginPath","radius","moveTo","arcTo","rect","closePath","clip","resetShadow","shadowColor","fillStyle","fill","fillRect","lineWidth","strokeStyle","stroke","strokeRect","customDrawer","children","slice","sort","forEach","drawChild","child"],"mappings":"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","sourcesContent":["import { Node, Frame } from './Node';\nimport {\n  getMergedStyleFromNode,\n  getFrameFromNode,\n  sortByZIndexAscending,\n  setShadow,\n  pushOpacity,\n  adapter\n} from './utils';\nimport { Container } from './Container';\nimport { getCache, createCache, autoCacheId } from './offscreen';\nimport { RevasCanvas } from './Canvas';\n\nfunction getRadius(style: any) {\n  return {\n    tl: style.borderTopLeftRadius || style.borderRadius || 0,\n    tr: style.borderTopRightRadius || style.borderRadius || 0,\n    bl: style.borderBottomLeftRadius || style.borderRadius || 0,\n    br: style.borderBottomRightRadius || style.borderRadius || 0,\n  };\n}\n\nexport function drawNode(canvas: RevasCanvas, node: Node, container: Container) {\n  const style = getMergedStyleFromNode(node, container.draw);\n  const frame = getFrameFromNode(node);\n\n  if (style.opacity <= 0) {\n    return;\n  }\n\n  // flags\n  const hasTransform =\n    style.translateX || style.translateY || style.rotate || style.scaleX || style.scaleY || style.scale;\n  const hasClip = style.overflow === 'hidden';\n\n  if (hasClip) {\n    canvas.context.save();\n  } else if (hasTransform) {\n    canvas.transform.save();\n  }\n  // Area Range\n\n  // Opacity:\n  const popOpacity = pushOpacity(canvas, style.opacity);\n\n  // Translation:\n  if (style.translateX || style.translateY) {\n    canvas.transform.translate(style.translateX || 0, style.translateY || 0);\n  }\n  // Rotate && Scale\n  if (style.rotate || style.scaleX || style.scaleY || style.scale) {\n    // Origin Center\n    const originX = frame.x + frame.width / 2;\n    const originY = frame.y + frame.height / 2;\n    canvas.transform.translate(originX, originY);\n    if (style.rotate) {\n      canvas.transform.rotate(style.rotate);\n    }\n    if (style.scaleX || style.scaleY || style.scale) {\n      canvas.transform.scale(style.scaleX || style.scale, style.scaleY || style.scale);\n    }\n    canvas.transform.translate(-originX, -originY);\n  }\n\n  if (node.props.cache && adapter.createOffscreenCanvas && frame.height > 0 && frame.width > 0) {\n    drawCache(canvas, node, container, style, frame, hasClip);\n  } else {\n    drawContent(canvas, node, container, style, frame, hasClip);\n  }\n\n  popOpacity();\n\n  if (hasClip) {\n    canvas.context.restore();\n  } else if (hasTransform) {\n    canvas.transform.restore();\n  }\n}\n\nfunction drawCache(canvas: RevasCanvas, node: Node, container: Container, style: any, frame: Frame, hasClip: boolean) {\n  const cachedId = node.props.cache === true ? autoCacheId(node) : node.props.cache;\n  let cached = getCache(cachedId);\n  const { shadowBlur = 0, shadowOffsetX = 0, shadowOffsetY = 0 } = cached ? cached.style : style;\n  const spread = shadowBlur * 2;\n  const x = frame.x + shadowOffsetX - shadowBlur;\n  const y = frame.y + shadowOffsetY - shadowBlur;\n  const w = frame.width + spread;\n  const h = frame.height + spread;\n  if (!cached) {\n    if (!node.$ready && !node.props.forceCache) {\n      return drawContent(canvas, node, container, style, frame, hasClip);\n    }\n    cached = createCache(style, w, h, cachedId);\n    cached.canvas.transform.translate(-x, -y);\n    drawContent(cached.canvas, node, container, style, frame, hasClip);\n    cached.canvas.transform.translate(x, y);\n  }\n  canvas.context.drawImage(cached.canvas.element, x, y, w, h);\n}\n\nfunction drawContent(\n  canvas: RevasCanvas,\n  node: Node,\n  container: Container,\n  style: any,\n  frame: Frame,\n  hasClip: boolean\n) {\n  const hasBG = style.backgroundColor && style.backgroundColor !== 'transparent';\n  const hasBorder = style.borderColor && style.borderWidth > 0;\n  const hasRadius =\n    style.borderRadius ||\n    style.borderTopLeftRadius ||\n    style.borderTopRightRadius ||\n    style.borderBottomLeftRadius ||\n    style.borderBottomRightRadius;\n\n  // consts\n  const useFrame = hasBG || hasBorder || hasClip || style.path;\n  const usePath = hasRadius || hasClip || style.path;\n\n  if (useFrame) {\n    const { context: ctx } = canvas;\n    if (usePath) {\n      // Draw Path\n      ctx.beginPath();\n      if (hasRadius) {\n        const radius = getRadius(style);\n        ctx.moveTo(frame.x + radius.tl, frame.y);\n        ctx.arcTo(frame.x + frame.width, frame.y, frame.x + frame.width, frame.y + frame.height, radius.tr);\n        ctx.arcTo(frame.x + frame.width, frame.y + frame.height, frame.x, frame.y + frame.height, radius.br);\n        ctx.arcTo(frame.x, frame.y + frame.height, frame.x, frame.y, radius.bl);\n        ctx.arcTo(frame.x, frame.y, frame.x + frame.width, frame.y, radius.tl);\n      } else {\n        ctx.rect(frame.x, frame.y, frame.width, frame.height);\n      }\n      ctx.closePath();\n\n      if (hasClip) {\n        ctx.clip();\n      }\n    }\n\n    if (hasBG || hasBorder) {\n      // Shadow:\n      const resetShadow = setShadow(\n        canvas,\n        style.shadowColor,\n        style.shadowOffsetX,\n        style.shadowOffsetY,\n        style.shadowBlur\n      );\n      // Background color & Shadow\n      if (hasBG) {\n        ctx.fillStyle = style.backgroundColor;\n        if (usePath) {\n          ctx.fill();\n        } else {\n          ctx.fillRect(frame.x, frame.y, frame.width, frame.height);\n        }\n      }\n\n      // Border with border radius:\n      if (hasBorder) {\n        ctx.lineWidth = style.borderWidth;\n        ctx.strokeStyle = style.borderColor;\n        if (usePath) {\n          ctx.stroke();\n        } else {\n          ctx.strokeRect(frame.x, frame.y, frame.width, frame.height);\n        }\n      }\n      resetShadow();\n    }\n  }\n\n  if (node.props.customDrawer) {\n    node.props.customDrawer(canvas, node, { hasRadius, hasClip });\n  }\n\n  // Draw child layers, sorted by their z-index.\n  node.children\n    .slice()\n    .sort(sortByZIndexAscending)\n    .forEach(function drawChild(child) {\n      drawNode(canvas, child, container);\n    });\n}\n"]},"metadata":{},"sourceType":"module"}