{"code":"import { __spreadArrays } from \"tslib\";\r\nexport function noop() { }\r\nexport var EMPTY_OBJECT = Object.freeze({});\r\nexport var EMPTY_ARRAY = Object.freeze([]);\r\nexport function flatten(array) {\r\n    var flattend = [];\r\n    (function flat(array) {\r\n        array.forEach(function (el) {\r\n            if (Array.isArray(el)) {\r\n                flat(el);\r\n            }\r\n            else {\r\n                flattend.push(el);\r\n            }\r\n        });\r\n    })(array);\r\n    return flattend;\r\n}\r\nexport var now = typeof performance === 'object' && typeof performance.now === 'function' ? function () { return performance.now(); } : function () { return Date.now(); };\r\nfunction observeAnimatedValue(value, observer, defaultValue) {\r\n    if (value === undefined) {\r\n        return defaultValue;\r\n    }\r\n    if (value && value.getValue) {\r\n        return value.getValue(observer);\r\n    }\r\n    return value;\r\n}\r\nexport function applyAnimated(style, callback) {\r\n    if (style.animated) {\r\n        // Animated Styles\r\n        for (var key in style) {\r\n            style[key] = observeAnimatedValue(style[key], callback);\r\n        }\r\n    }\r\n    return style;\r\n}\r\nexport function getMergedStyleFromNode(node, callback) {\r\n    var _a = node.props.style, style = _a === void 0 ? EMPTY_ARRAY : _a;\r\n    return applyAnimated(Object.assign.apply(Object, __spreadArrays([{}], flatten([style]))), callback);\r\n}\r\nexport function getFrameFromNode(node) {\r\n    var frame = node.frame;\r\n    return frame;\r\n}\r\nexport function sortByZIndexAscending(a, b) {\r\n    var styleA = getMergedStyleFromNode(a);\r\n    var styleB = getMergedStyleFromNode(b);\r\n    return (styleA.zIndex || 0) - (styleB.zIndex || 0);\r\n}\r\nexport function clamp(n, min, max) {\r\n    return Math.min(Math.max(n, min), max);\r\n}\r\nvar ASTRAL_RANGE = /\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]?|[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?)*/g;\r\nvar WORD_RANGE = /\\w+|\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]?|[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]|\\ud83c[\\udffb-\\udfff])?)*/g;\r\nexport function getChars(str) {\r\n    return str.match(ASTRAL_RANGE) || EMPTY_ARRAY;\r\n}\r\nexport function getWords(str) {\r\n    return str.match(WORD_RANGE) || EMPTY_ARRAY;\r\n}\r\nexport function setShadow(canvas, color, x, y, blur) {\r\n    if (color) {\r\n        var ctx_1 = canvas.context;\r\n        var shadowBlur_1 = ctx_1.shadowBlur, shadowColor_1 = ctx_1.shadowColor, shadowOffsetX_1 = ctx_1.shadowOffsetX, shadowOffsetY_1 = ctx_1.shadowOffsetY;\r\n        ctx_1.shadowBlur = blur;\r\n        ctx_1.shadowColor = color;\r\n        ctx_1.shadowOffsetX = x;\r\n        ctx_1.shadowOffsetY = y;\r\n        return function resetShadow() {\r\n            ctx_1.shadowBlur = shadowBlur_1;\r\n            ctx_1.shadowColor = shadowColor_1;\r\n            ctx_1.shadowOffsetX = shadowOffsetX_1;\r\n            ctx_1.shadowOffsetY = shadowOffsetY_1;\r\n        };\r\n    }\r\n    return noop;\r\n}\r\nexport function pushOpacity(canvas, opacity) {\r\n    if (opacity !== null && opacity < 1 && opacity >= 0) {\r\n        var cachedOpacity_1 = canvas.context.globalAlpha || 1;\r\n        canvas.context.globalAlpha = cachedOpacity_1 * opacity;\r\n        return function popOpacity() {\r\n            canvas.context.globalAlpha = cachedOpacity_1;\r\n        };\r\n    }\r\n    return noop;\r\n}\r\nexport var adapter = {\r\n    createImage: function () { return new Image(); },\r\n};\r\n","references":["/Users/fimplus/Desktop/revasReal/src/revas/core/Node.ts","/Users/fimplus/Desktop/revasReal/src/revas/core/Canvas.ts"],"dts":{"name":"/Users/fimplus/Desktop/revasReal/dist/types/revas/core/utils.d.ts","writeByteOrderMark":false,"text":"import { Node } from './Node';\r\nimport { RevasCanvas } from './Canvas';\r\nexport declare function noop(): any;\r\nexport declare const EMPTY_OBJECT: any;\r\nexport declare const EMPTY_ARRAY: any[];\r\nexport declare function flatten(array: any[]): any[];\r\nexport declare const now: () => number;\r\nexport declare function applyAnimated(style: any, callback?: Function): any;\r\nexport declare function getMergedStyleFromNode(node: Node, callback?: Function): any;\r\nexport declare function getFrameFromNode(node: Node): import(\"./Node\").Frame;\r\nexport declare function sortByZIndexAscending(a: Node, b: Node): number;\r\nexport declare function clamp(n: number, min: number, max: number): number;\r\nexport declare function getChars(str: string): readonly string[];\r\nexport declare function getWords(str: string): readonly string[];\r\nexport declare function setShadow(canvas: RevasCanvas, color: string, x: number, y: number, blur: number): () => void;\r\nexport declare function pushOpacity(canvas: RevasCanvas, opacity: number): typeof noop;\r\nexport declare type RevasAdapter = {\r\n    createImage: () => HTMLImageElement;\r\n    createOffscreenCanvas?: (width: number, height: number) => RevasCanvas;\r\n    resetOffscreenCanvas?: (ctx: RevasCanvas, width: number, height: number) => RevasCanvas;\r\n};\r\nexport declare const adapter: RevasAdapter;\r\n"}}
