{"code":"import { __extends } from \"tslib\";\r\nimport bezier from 'bezier-easing';\r\nvar AnimatedNode = /** @class */ (function () {\r\n    function AnimatedNode() {\r\n    }\r\n    AnimatedNode.prototype.interpolate = function (inRange, outRange, ease) {\r\n        if (ease === void 0) { ease = Easing.linear; }\r\n        return new AnimatedInterpolate(this, inRange, outRange, ease);\r\n    };\r\n    return AnimatedNode;\r\n}());\r\nexport { AnimatedNode };\r\nvar AnimatedValue = /** @class */ (function (_super) {\r\n    __extends(AnimatedValue, _super);\r\n    function AnimatedValue(_value) {\r\n        var _this = _super.call(this) || this;\r\n        _this._value = _value;\r\n        return _this;\r\n    }\r\n    AnimatedValue.prototype.setValue = function (value) {\r\n        this._value = value;\r\n        if (this._observer) {\r\n            var observer = this._observer;\r\n            this._observer = void 0;\r\n            observer();\r\n        }\r\n    };\r\n    AnimatedValue.prototype.getValue = function (observer) {\r\n        if (observer) {\r\n            this._observer = observer;\r\n        }\r\n        return this._value;\r\n    };\r\n    return AnimatedValue;\r\n}(AnimatedNode));\r\nexport { AnimatedValue };\r\nvar AnimatedInterpolate = /** @class */ (function (_super) {\r\n    __extends(AnimatedInterpolate, _super);\r\n    function AnimatedInterpolate(source, inRange, outRange, ease) {\r\n        var _this = _super.call(this) || this;\r\n        _this.source = source;\r\n        _this.inRange = inRange;\r\n        _this.outRange = outRange;\r\n        _this.ease = ease;\r\n        return _this;\r\n    }\r\n    // TODO: Check inRange is asc\r\n    AnimatedInterpolate.prototype.getValue = function (observer) {\r\n        var value = this.source.getValue(observer);\r\n        var len = this.inRange.length;\r\n        var i = 1;\r\n        for (; i < len; i++) {\r\n            var x1 = this.inRange[i];\r\n            if (value < x1 || i === len - 1) {\r\n                var x0 = this.inRange[i - 1];\r\n                var y0 = this.outRange[i - 1];\r\n                var y1 = this.outRange[i];\r\n                var percent = (value - x0) / (x1 - x0);\r\n                var result = (y1 - y0) * this.ease(percent) + y0;\r\n                return result;\r\n            }\r\n        }\r\n        return 0;\r\n    };\r\n    return AnimatedInterpolate;\r\n}(AnimatedNode));\r\nexport { AnimatedInterpolate };\r\nvar AnimatedTiming = /** @class */ (function () {\r\n    function AnimatedTiming(value, config) {\r\n        var _this = this;\r\n        this.value = value;\r\n        this.config = config;\r\n        this._startTime = 0;\r\n        this._startValue = 0;\r\n        this._next = 0;\r\n        this._loop = function () {\r\n            var duration = Date.now() - _this._startTime;\r\n            if (duration < _this.config.duration) {\r\n                var percent = duration / _this.config.duration;\r\n                var inc = _this._ease(percent) * (_this.config.to - _this._startValue);\r\n                _this.value.setValue(_this._startValue + inc);\r\n                _this._next = requestAnimationFrame(_this._loop);\r\n            }\r\n            else {\r\n                _this.value.setValue(_this.config.to);\r\n                _this._onEnd && requestAnimationFrame(_this._onEnd);\r\n            }\r\n        };\r\n    }\r\n    Object.defineProperty(AnimatedTiming.prototype, \"_ease\", {\r\n        get: function () {\r\n            return this.config.ease || Easing.linear;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    AnimatedTiming.prototype.start = function (onEnd) {\r\n        this._startTime = Date.now();\r\n        this._startValue = this.value.getValue();\r\n        this._onEnd = onEnd;\r\n        this._next = requestAnimationFrame(this._loop);\r\n        return this;\r\n    };\r\n    AnimatedTiming.prototype.stop = function () {\r\n        cancelAnimationFrame(this._next);\r\n        return this;\r\n    };\r\n    AnimatedTiming.prototype.promise = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve) { return (_this._onEnd = resolve); });\r\n    };\r\n    return AnimatedTiming;\r\n}());\r\nexport { AnimatedTiming };\r\nexport function timing(value, config) {\r\n    return new AnimatedTiming(value, config);\r\n}\r\nvar ease;\r\nfunction getEase() {\r\n    if (!ease) {\r\n        ease = bezier(0.42, 0, 1, 1);\r\n    }\r\n    return ease;\r\n}\r\nexport var Easing = {\r\n    linear: function (t) {\r\n        return t;\r\n    },\r\n    ease: function (t) {\r\n        return getEase()(t);\r\n    },\r\n    /**\r\n     * Runs an easing function forwards.\r\n     */\r\n    in: function (easing) {\r\n        if (easing === void 0) { easing = getEase(); }\r\n        return easing;\r\n    },\r\n    /**\r\n     * Runs an easing function backwards.\r\n     */\r\n    out: function (easing) {\r\n        if (easing === void 0) { easing = getEase(); }\r\n        return function (t) { return 1 - easing(1 - t); };\r\n    },\r\n    /**\r\n     * Makes any easing function symmetrical. The easing function will run\r\n     * forwards for half of the duration, then backwards for the rest of the\r\n     * duration.\r\n     */\r\n    inOut: function (easing) {\r\n        if (easing === void 0) { easing = getEase(); }\r\n        return function (t) {\r\n            if (t < 0.5) {\r\n                return easing(t * 2) / 2;\r\n            }\r\n            return 1 - easing((1 - t) * 2) / 2;\r\n        };\r\n    },\r\n    bounce: function (t) {\r\n        if (t < 1 / 2.75) {\r\n            return 7.5625 * t * t;\r\n        }\r\n        if (t < 2 / 2.75) {\r\n            var t2_1 = t - 1.5 / 2.75;\r\n            return 7.5625 * t2_1 * t2_1 + 0.75;\r\n        }\r\n        if (t < 2.5 / 2.75) {\r\n            var t2_2 = t - 2.25 / 2.75;\r\n            return 7.5625 * t2_2 * t2_2 + 0.9375;\r\n        }\r\n        var t2 = t - 2.625 / 2.75;\r\n        return 7.5625 * t2 * t2 + 0.984375;\r\n    },\r\n    elastic: function (bounciness) {\r\n        if (bounciness === void 0) { bounciness = 1; }\r\n        var p = bounciness * Math.PI;\r\n        return function (t) { return 1 - Math.pow(Math.cos((t * Math.PI) / 2), 3) * Math.cos(t * p); };\r\n    },\r\n};\r\n","references":["/Users/fimplus/Desktop/revasReal/node_modules/bezier-easing/src/index.d.ts"],"dts":{"name":"/Users/fimplus/Desktop/revasReal/dist/types/revas/core/Animated.d.ts","writeByteOrderMark":false,"text":"export declare abstract class AnimatedNode {\r\n    abstract getValue(observer?: Function): number;\r\n    interpolate(inRange: number[], outRange: number[], ease?: (t: number) => number): AnimatedInterpolate;\r\n}\r\nexport declare class AnimatedValue extends AnimatedNode {\r\n    private _value;\r\n    private _observer?;\r\n    constructor(_value: number);\r\n    setValue(value: number): void;\r\n    getValue(observer?: Function): number;\r\n}\r\nexport declare class AnimatedInterpolate extends AnimatedNode {\r\n    private source;\r\n    private inRange;\r\n    private outRange;\r\n    private ease;\r\n    constructor(source: AnimatedNode, inRange: number[], outRange: number[], ease: (t: number) => number);\r\n    getValue(observer?: Function): number;\r\n}\r\nexport declare type TimingConfig = {\r\n    to: number;\r\n    duration: number;\r\n    ease?: (t: number) => number;\r\n};\r\nexport declare class AnimatedTiming {\r\n    private value;\r\n    private config;\r\n    private _startTime;\r\n    private _startValue;\r\n    private _onEnd?;\r\n    private _next;\r\n    constructor(value: AnimatedValue, config: TimingConfig);\r\n    private get _ease();\r\n    start(onEnd?: Function): this;\r\n    stop(): this;\r\n    promise(): Promise<unknown>;\r\n    private _loop;\r\n}\r\nexport declare function timing(value: AnimatedValue, config: TimingConfig): AnimatedTiming;\r\nexport declare const Easing: {\r\n    linear(t: number): number;\r\n    ease(t: number): number;\r\n    /**\r\n     * Runs an easing function forwards.\r\n     */\r\n    in(easing?: (t: number) => number): (t: number) => number;\r\n    /**\r\n     * Runs an easing function backwards.\r\n     */\r\n    out(easing?: (t: number) => number): (t: number) => number;\r\n    /**\r\n     * Makes any easing function symmetrical. The easing function will run\r\n     * forwards for half of the duration, then backwards for the rest of the\r\n     * duration.\r\n     */\r\n    inOut(easing?: (t: number) => number): (t: number) => number;\r\n    bounce(t: number): number;\r\n    elastic(bounciness?: number): (t: number) => number;\r\n};\r\n"}}
