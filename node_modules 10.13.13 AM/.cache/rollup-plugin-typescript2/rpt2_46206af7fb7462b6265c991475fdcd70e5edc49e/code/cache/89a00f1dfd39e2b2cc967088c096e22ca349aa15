{"code":"import * as imageLoader from './imageLoader';\r\nimport { clamp, getMergedStyleFromNode, getFrameFromNode } from '../../core/utils';\r\nexport default function drawImage(canvas, node, flags) {\r\n    var image = imageLoader.get(node.props.src);\r\n    if (image.height <= 0) {\r\n        return;\r\n    }\r\n    var frame = getFrameFromNode(node);\r\n    var width = frame.width, height = frame.height, x = frame.x, y = frame.y;\r\n    if (width <= 0 || height <= 0) {\r\n        return;\r\n    }\r\n    var style = getMergedStyleFromNode(node);\r\n    var actualSize = {\r\n        width: image.width,\r\n        height: image.height,\r\n    };\r\n    var focusPoint = style.focusPoint || {\r\n        x: actualSize.width * 0.5,\r\n        y: actualSize.height * 0.5,\r\n    };\r\n    var hasClip = flags.hasRadius && !flags.hasClip;\r\n    if (hasClip) {\r\n        canvas.context.save();\r\n        canvas.context.clip();\r\n    }\r\n    if (style.resizeMode === 'contain') {\r\n        var scale = Math.min(width / actualSize.width, height / actualSize.height) || 1;\r\n        var scaledSize = {\r\n            width: actualSize.width * scale,\r\n            height: actualSize.height * scale,\r\n        };\r\n        // Clip the image to rectangle (sx, sy, sw, sh).\r\n        var sw = Math.round(actualSize.width);\r\n        var sh = Math.round(actualSize.height);\r\n        // Scale the image to dimensions (dw, dh).\r\n        var dw = Math.round(scaledSize.width);\r\n        var dh = Math.round(scaledSize.height);\r\n        // Draw the image on the canvas at coordinates (dx, dy).\r\n        var dx = Math.round((width - scaledSize.width) / 2 + x);\r\n        var dy = Math.round((height - scaledSize.height) / 2 + y);\r\n        canvas.context.drawImage(image, 0, 0, sw, sh, dx, dy, dw, dh);\r\n    }\r\n    else {\r\n        var scale = Math.max(width / actualSize.width, height / actualSize.height) || 1;\r\n        var scaledSize = {\r\n            width: actualSize.width * scale,\r\n            height: actualSize.height * scale,\r\n        };\r\n        // Clip the image to rectangle (sx, sy, sw, sh).\r\n        var sx = Math.round(clamp(width * 0.5 - focusPoint.x * scale, width - scaledSize.width, 0)) * (-1 / scale);\r\n        var sy = Math.round(clamp(height * 0.5 - focusPoint.y * scale, height - scaledSize.height, 0)) * (-1 / scale);\r\n        var sw = Math.round(actualSize.width - sx * 2);\r\n        var sh = Math.round(actualSize.height - sy * 2);\r\n        // Scale the image to dimensions (dw, dh).\r\n        var dw = Math.round(width);\r\n        var dh = Math.round(height);\r\n        // Draw the image on the canvas at coordinates (dx, dy).\r\n        var dx = Math.round(x);\r\n        var dy = Math.round(y);\r\n        canvas.context.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);\r\n    }\r\n    if (hasClip) {\r\n        canvas.context.restore();\r\n    }\r\n}\r\n","references":["/Users/fimplus/Desktop/revasReal/src/revas/core/Node.ts","/Users/fimplus/Desktop/revasReal/src/revas/components/common/imageLoader.ts","/Users/fimplus/Desktop/revasReal/src/revas/core/utils.ts","/Users/fimplus/Desktop/revasReal/src/revas/core/Canvas.ts"],"dts":{"name":"/Users/fimplus/Desktop/revasReal/dist/types/revas/components/common/drawImage.d.ts","writeByteOrderMark":false,"text":"import { Node } from '../../core/Node';\r\nimport { RevasCanvas } from '../../core/Canvas';\r\nexport default function drawImage(canvas: RevasCanvas, node: Node, flags: any): void;\r\n"}}
