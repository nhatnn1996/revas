{"code":"import { getMergedStyleFromNode, getFrameFromNode, sortByZIndexAscending, setShadow, pushOpacity, adapter } from './utils';\r\nimport { getCache, createCache, autoCacheId } from './offscreen';\r\nfunction getRadius(style) {\r\n    return {\r\n        tl: style.borderTopLeftRadius || style.borderRadius || 0,\r\n        tr: style.borderTopRightRadius || style.borderRadius || 0,\r\n        bl: style.borderBottomLeftRadius || style.borderRadius || 0,\r\n        br: style.borderBottomRightRadius || style.borderRadius || 0,\r\n    };\r\n}\r\nexport function drawNode(canvas, node, container) {\r\n    var style = getMergedStyleFromNode(node, container.draw);\r\n    var frame = getFrameFromNode(node);\r\n    if (style.opacity <= 0) {\r\n        return;\r\n    }\r\n    // flags\r\n    var hasTransform = style.translateX || style.translateY || style.rotate || style.scaleX || style.scaleY || style.scale;\r\n    var hasClip = style.overflow === 'hidden';\r\n    if (hasClip) {\r\n        canvas.context.save();\r\n    }\r\n    else if (hasTransform) {\r\n        canvas.transform.save();\r\n    }\r\n    // Area Range\r\n    // Opacity:\r\n    var popOpacity = pushOpacity(canvas, style.opacity);\r\n    // Translation:\r\n    if (style.translateX || style.translateY) {\r\n        canvas.transform.translate(style.translateX || 0, style.translateY || 0);\r\n    }\r\n    // Rotate && Scale\r\n    if (style.rotate || style.scaleX || style.scaleY || style.scale) {\r\n        // Origin Center\r\n        var originX = frame.x + frame.width / 2;\r\n        var originY = frame.y + frame.height / 2;\r\n        canvas.transform.translate(originX, originY);\r\n        if (style.rotate) {\r\n            canvas.transform.rotate(style.rotate);\r\n        }\r\n        if (style.scaleX || style.scaleY || style.scale) {\r\n            canvas.transform.scale(style.scaleX || style.scale, style.scaleY || style.scale);\r\n        }\r\n        canvas.transform.translate(-originX, -originY);\r\n    }\r\n    if (node.props.cache && adapter.createOffscreenCanvas && frame.height > 0 && frame.width > 0) {\r\n        drawCache(canvas, node, container, style, frame, hasClip);\r\n    }\r\n    else {\r\n        drawContent(canvas, node, container, style, frame, hasClip);\r\n    }\r\n    popOpacity();\r\n    if (hasClip) {\r\n        canvas.context.restore();\r\n    }\r\n    else if (hasTransform) {\r\n        canvas.transform.restore();\r\n    }\r\n}\r\nfunction drawCache(canvas, node, container, style, frame, hasClip) {\r\n    var cachedId = node.props.cache === true ? autoCacheId(node) : node.props.cache;\r\n    var cached = getCache(cachedId);\r\n    var _a = cached ? cached.style : style, _b = _a.shadowBlur, shadowBlur = _b === void 0 ? 0 : _b, _c = _a.shadowOffsetX, shadowOffsetX = _c === void 0 ? 0 : _c, _d = _a.shadowOffsetY, shadowOffsetY = _d === void 0 ? 0 : _d;\r\n    var spread = shadowBlur * 2;\r\n    var x = frame.x + shadowOffsetX - shadowBlur;\r\n    var y = frame.y + shadowOffsetY - shadowBlur;\r\n    var w = frame.width + spread;\r\n    var h = frame.height + spread;\r\n    if (!cached) {\r\n        if (!node.$ready && !node.props.forceCache) {\r\n            return drawContent(canvas, node, container, style, frame, hasClip);\r\n        }\r\n        cached = createCache(style, w, h, cachedId);\r\n        cached.canvas.transform.translate(-x, -y);\r\n        drawContent(cached.canvas, node, container, style, frame, hasClip);\r\n        cached.canvas.transform.translate(x, y);\r\n    }\r\n    canvas.context.drawImage(cached.canvas.element, x, y, w, h);\r\n}\r\nfunction drawContent(canvas, node, container, style, frame, hasClip) {\r\n    var hasBG = style.backgroundColor && style.backgroundColor !== 'transparent';\r\n    var hasBorder = style.borderColor && style.borderWidth > 0;\r\n    var hasRadius = style.borderRadius ||\r\n        style.borderTopLeftRadius ||\r\n        style.borderTopRightRadius ||\r\n        style.borderBottomLeftRadius ||\r\n        style.borderBottomRightRadius;\r\n    // consts\r\n    var useFrame = hasBG || hasBorder || hasClip || style.path;\r\n    var usePath = hasRadius || hasClip || style.path;\r\n    if (useFrame) {\r\n        var ctx = canvas.context;\r\n        if (usePath) {\r\n            // Draw Path\r\n            ctx.beginPath();\r\n            if (hasRadius) {\r\n                var radius = getRadius(style);\r\n                ctx.moveTo(frame.x + radius.tl, frame.y);\r\n                ctx.arcTo(frame.x + frame.width, frame.y, frame.x + frame.width, frame.y + frame.height, radius.tr);\r\n                ctx.arcTo(frame.x + frame.width, frame.y + frame.height, frame.x, frame.y + frame.height, radius.br);\r\n                ctx.arcTo(frame.x, frame.y + frame.height, frame.x, frame.y, radius.bl);\r\n                ctx.arcTo(frame.x, frame.y, frame.x + frame.width, frame.y, radius.tl);\r\n            }\r\n            else {\r\n                ctx.rect(frame.x, frame.y, frame.width, frame.height);\r\n            }\r\n            ctx.closePath();\r\n            if (hasClip) {\r\n                ctx.clip();\r\n            }\r\n        }\r\n        if (hasBG || hasBorder) {\r\n            // Shadow:\r\n            var resetShadow = setShadow(canvas, style.shadowColor, style.shadowOffsetX, style.shadowOffsetY, style.shadowBlur);\r\n            // Background color & Shadow\r\n            if (hasBG) {\r\n                ctx.fillStyle = style.backgroundColor;\r\n                if (usePath) {\r\n                    ctx.fill();\r\n                }\r\n                else {\r\n                    ctx.fillRect(frame.x, frame.y, frame.width, frame.height);\r\n                }\r\n            }\r\n            // Border with border radius:\r\n            if (hasBorder) {\r\n                ctx.lineWidth = style.borderWidth;\r\n                ctx.strokeStyle = style.borderColor;\r\n                if (usePath) {\r\n                    ctx.stroke();\r\n                }\r\n                else {\r\n                    ctx.strokeRect(frame.x, frame.y, frame.width, frame.height);\r\n                }\r\n            }\r\n            resetShadow();\r\n        }\r\n    }\r\n    if (node.props.customDrawer) {\r\n        node.props.customDrawer(canvas, node, { hasRadius: hasRadius, hasClip: hasClip });\r\n    }\r\n    // Draw child layers, sorted by their z-index.\r\n    node.children\r\n        .slice()\r\n        .sort(sortByZIndexAscending)\r\n        .forEach(function drawChild(child) {\r\n        drawNode(canvas, child, container);\r\n    });\r\n}\r\n","references":["/Users/fimplus/Desktop/revasReal/src/revas/core/Node.ts","/Users/fimplus/Desktop/revasReal/src/revas/core/utils.ts","/Users/fimplus/Desktop/revasReal/src/revas/core/Container.ts","/Users/fimplus/Desktop/revasReal/src/revas/core/offscreen.ts","/Users/fimplus/Desktop/revasReal/src/revas/core/Canvas.ts"],"dts":{"name":"/Users/fimplus/Desktop/revasReal/dist/types/revas/core/draw.d.ts","writeByteOrderMark":false,"text":"import { Node } from './Node';\r\nimport { Container } from './Container';\r\nimport { RevasCanvas } from './Canvas';\r\nexport declare function drawNode(canvas: RevasCanvas, node: Node, container: Container): void;\r\n"}}
